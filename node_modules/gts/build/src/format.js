"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const lint_1 = require("./lint");
const clangFormat = require('clang-format');
const baseArgs = ['-style', '{Language: JavaScript, BasedOnStyle: Google, ColumnLimit: 80}'];
/**
 * Run tslint fix and clang fix with the default configuration
 * @param options
 * @param fix whether to automatically fix the format
 * @param files files to format
 */
function format(options, files = [], fix = false) {
    return __awaiter(this, void 0, void 0, function* () {
        const program = lint_1.createProgram(options);
        // Obtain a list of source files to format.
        // We use program.getRootFileNames to get only the files that match the
        // include patterns specified in the given tsconfig.json file (as specified
        // through options). This is necessary because we only want to format files
        // over which the developer has control (i.e. not auto-generated or
        // third-party source files).
        const srcFiles = files.length > 0 ?
            files :
            program.getRootFileNames().filter(f => !f.endsWith('.d.ts'));
        if (fix) {
            return yield fixFormat(srcFiles);
        }
        else {
            const result = yield checkFormat(srcFiles);
            if (!result) {
                options.logger.log('clang-format reported errors... run `gts fix` to address.');
            }
            return result;
        }
    });
}
exports.format = format;
/**
 * Runs clang-format to automatically fix the format of supplied files.
 *
 * @param srcFiles list of source files
 */
function fixFormat(srcFiles) {
    return new Promise((resolve, reject) => {
        const args = baseArgs.concat(['-i'], srcFiles);
        clangFormat.spawnClangFormat(args, (err) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(true);
            }
        }, 'inherit');
    });
}
/**
 * Runs clang-format on the list of files and checks whether they are formatted
 * correctly. Returns true if all files are formatted correctly.
 *
 * @param srcFiles list of source files
 */
function checkFormat(srcFiles) {
    return new Promise((resolve, reject) => {
        let output = '';
        const args = baseArgs.concat(['-output-replacements-xml'], srcFiles);
        const out = clangFormat
            .spawnClangFormat(args, (err) => {
            if (err) {
                reject(err);
            }
        }, ['ignore', 'pipe', process.stderr])
            .stdout;
        out.setEncoding('utf8');
        out.on('data', (data) => {
            output += data;
        });
        out.on('end', () => {
            resolve(output.indexOf('<replacement ') === -1 ? true : false);
        });
    });
}
//# sourceMappingURL=format.js.map